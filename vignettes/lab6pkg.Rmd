---
title: "lab6pkg"
author: "Aqsa, Oliver and Samira"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{lab6pkg}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(lab6pkg)
```


```{r}
suppressWarnings(RNGversion("3.5.9"))
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
knapsack_objects <- data.frame(
  w=sample(1:4000, size = n, replace = TRUE),
  v=runif(n = n, 0, 10000))
```

# **The Knapsack Problem**

This package contain three different functions for solving _the Knapsack Problem_:

**1. brute_force_knapsack**

**2. knapsack_dynamic**

**3. greedy_knapsack**

## First function: **brute_force_knapsack()**

The only solution that is guaranteed to give a correct answer in all situations for the knapsack problem
is using brute-force search, i.e. going through all possible alternatives and return the maximum value
found. This approach is of complexity $O(2^n)$ since all possible combinations $2^n$ needs to be evaluated.


The Algorithm can be executed as shown below. The time taken for 16 objects is shown below.

```{r runCode, echo=TRUE}
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 16
knapsack_objects <- data.frame(w=sample(1:4000, size = n, replace = TRUE),v=runif(n = n, 0, 10000))
brute_force_knapsack(knapsack_objects[1:12,],2000)
system.time(brute_force_knapsack(knapsack_objects[1:12,],3500))
system.time(brute_force_knapsack(knapsack_objects[1:12,],3500,parallel=TRUE))
```

<p> After Parallelizing, the run time shortened significantly.
 
<p> After profiling, it can be seen that it is taking too much time in serial operation.The time taken for $n=16$ objects.



## Second function: **Knapsack_dynamic()**
<p> The Algorithm can be executed and the time taken for n=500 objects as shown below. As it can be seen that dynamic algorithm is  faster than the Brute Force because the dynamic algorithm will run in $O(Wn)$

```{r}
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 500
knapsack_objects <- data.frame(w=sample(1:4000, size = n, replace = TRUE),v=runif(n = n, 0, 10000))
knapsack_dynamic(knapsack_objects[1:12,],3500)
system.time(knapsack_dynamic(knapsack_objects[1:12,],3500))

```

## Third function: **greedy_knapsack()**
<p> The Algorithm can be executed and the time taken for n=10000 objects as shown below. Greedy algorithm is the fastest of all because the computational complexity for this algorithm is $O(nlogn)$ due to its sorting mechanism.  

```{r}
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 10000
knapsack_objects <- data.frame(w=sample(1:4000, size = n, replace = TRUE),v=runif(n = n, 0, 10000))
greedy_knapsack(knapsack_objects[1:12,],3500)
system.time(greedy_knapsack(knapsack_objects[1:12,],3500))
```
